/*
* Copyright (c) 2023, Intel Corporation. All rights reserved.<BR>
* SPDX-License-Identifier: Apache-2.0
 */

package quote

import (
	"bytes"
	"context"
	"encoding/base64"
	"encoding/binary"
	"log"
	"strings"
	"time"

	pb "github.com/intel/confidential-cloud-native-primitives/sdk/golang/ccnp/quote/proto"
	pkgerrors "github.com/pkg/errors"
	"google.golang.org/grpc"
)

const (
	UDS_PATH = "unix:/run/ccnp/uds/quote-server.sock"
	TYPE_TDX = "TDX"
	TYPE_TPM = "TPM"
)

type TPMQuote struct{}

type TDXQuote struct {
	Quote          []uint8    // full TD quote
	Version        uint16     // TD quote version
	Tdreport       [584]uint8 // full TD report
	TeeType        uint32     // Type of TEE for which the Quote has been generated
	TeeTcbSvn      [16]uint8  // Array of TEE TCB SVNs
	Mrseam         [48]uint8  // Measurement of the SEAM module (SHA384 hash)
	Mrsignerseam   [48]uint8  // Measurement of a 3rd party SEAM module’s signer (SHA384 hash)
	SeamAttributes [8]uint8   // ATTRIBUTES of SEAM
	TdAttributes   [8]uint8   // ATTRIBUTES of TD
	Xfam           [8]uint8   // XFAM of TD
	Mrtd           [48]uint8  // Measurement of the initial contents of the TD (SHA384 hash)
	Mrconfigid     [48]uint8  // Software defined ID for non-owner-defined configuration of the TD
	Mrowner        [48]uint8  // Software defined ID for the guest TD’s owner
	Mrownerconfig  [48]uint8  // Software defined ID for owner-defined configuration of the TD
	Rtmrs          [192]uint8 // Array of 4 runtime extendable measurement registers (SHA384 hash)
	ReportData     [64]uint8  // Additional Report Data
	Signature      [64]uint8  // ECDSA signature, r component followed by s component, 2 x 32 bytes
	AttestationKey [64]uint8  // Public part of ECDSA Attestation Key generated by Quoting Enclave
	CertData       []uint8    // Data required to certify Attestation Key used to sign the Quote
}

// definition of the quote header and TDReport at:
// https://github.com/intel/SGXDataCenterAttestationPrimitives/blob/master/QuoteGeneration/quote_wrapper/common/inc/sgx_quote_4.h#L112
type SGXQuoteHeader struct {
	Version    uint16    // The version this quote structure.
	AttKeyType uint16    // sgx_attestation_algorithm_id_t.  Describes the type of signature in the signature_data[] field.
	TeeType    uint32    // Type of Trusted Execution Environment for which the Quote has been generated. Supported values: 0 (SGX), 0x81(TDX)
	Reserved   uint32    // Reserved field.
	VendorId   [16]uint8 // Unique identifier of QE Vendor.
	UserData   [20]uint8 // Custom attestation key owner data.
}

type TDReport struct {
	TeeTcbSvn      [16]uint8
	Mrseam         [48]uint8
	Mrsignerseam   [48]uint8
	SeamAttributes [8]uint8
	TdAttributes   [8]uint8
	Xfam           [8]uint8
	Mrtd           [48]uint8
	Mrconfigid     [48]uint8
	Mrowner        [48]uint8
	Mrownerconfig  [48]uint8
	Rtmrs          [192]uint8
	ReportData     [64]uint8
}

const (
	QuoteHeaderOffset                 = 0   // 48 bytes quote header, start from index 0 of quote string
	QuoteTDReportOffset               = 48  // 584 bytes tdreport, start from index 48 of quote string
	QuoteAuthDataSizeOffset           = 632 // 4 bytes auth size, start from index 632 of quote string
	QuoteAuthDataContentOffset        = 636 // authSize bytes in auth_data, start from index 636 of quote string
	QuoteAuthDataSignatureOffset      = 700 // 64 bytes of signature in auth_data, start from index 700 of quote string
	QuoteAuthDataAttestationKeyOffset = 764 // 64 bytes of attestation_key in auth_data, start from index 764 of quote string
	QuoteAuthDataCertDataOffset       = 770 // (authSize-6-128) bytes of cert_data in auth_data, start from index 770 of quote string
)

func GetQuote(userData string, nonce string) (interface{}, error) {

	channel, err := grpc.Dial(UDS_PATH, grpc.WithInsecure())
	if err != nil {
		log.Fatalf("[GetQuote] can not connect to UDS: %v", err)
	}
	defer channel.Close()

	client := pb.NewGetQuoteClient(channel)

	ctx, cancel := context.WithTimeout(context.Background(), time.Second)
	defer cancel()

	response, err := client.GetQuote(ctx, &pb.GetQuoteRequest{UserData: userData, Nonce: nonce})
	if err != nil {
		log.Fatalf("[GetQuote] fail to get quote: %v", err)
	}

	quote, err := base64.StdEncoding.DecodeString(strings.Trim(response.Quote, "\""))
	if err != nil {
		log.Fatalf("[GetQuote] decode quote error: %v", err)
	}

	switch response.QuoteType {
	case TYPE_TDX:
		return parseTDXQuote(quote)
	case TYPE_TPM:
		return parseTPMQuote(quote)
	default:
		log.Fatalf("[GetQuote] unknown TEE enviroment!")
	}

	return nil, pkgerrors.New("[GetQuote] unknown TEE enviroment!")
}

func parseTDXQuote(quote []byte) (interface{}, error) {

	var header = SGXQuoteHeader{}
	var err = binary.Read(bytes.NewReader(quote[QuoteHeaderOffset:QuoteTDReportOffset]), binary.LittleEndian, &header)
	if err != nil {
		log.Fatalf("[parseTDXQuote] fail to parse quote header: %v", err)
	}

	var tdreport = TDReport{}
	err = binary.Read(bytes.NewReader(quote[QuoteTDReportOffset:QuoteAuthDataSizeOffset]), binary.LittleEndian, &tdreport)
	if err != nil {
		log.Fatalf("[parseTDXQuote] fail to parse quote tdreport: %v", err)
	}

	var authSize uint32 = 0
	err = binary.Read(bytes.NewReader(quote[QuoteAuthDataSizeOffset:QuoteAuthDataContentOffset]), binary.LittleEndian, &authSize)
	if err != nil {
		log.Fatalf("[parseTDXQuote] fail to parse quote auth data size: %v", err)
	}

	var signature = [64]uint8{}
	err = binary.Read(bytes.NewReader(quote[QuoteAuthDataContentOffset:QuoteAuthDataSignatureOffset]), binary.LittleEndian, &signature)
	if err != nil {
		log.Fatalf("[parseTDXQuote] fail to parse quote signature: %v", err)
	}

	var attestationKey = [64]uint8{}
	err = binary.Read(bytes.NewReader(quote[QuoteAuthDataSignatureOffset:QuoteAuthDataAttestationKeyOffset]), binary.LittleEndian, &attestationKey)
	if err != nil {
		log.Fatalf("[parseTDXQuote] fail to parse quote attestation key: %v", err)
	}

	var certData = make([]uint8, authSize-128-6)
	err = binary.Read(bytes.NewReader(quote[QuoteAuthDataCertDataOffset:QuoteAuthDataCertDataOffset+authSize-6-128]), binary.LittleEndian, &certData)
	if err != nil {
		log.Fatalf("[parseTDXQuote] fail to parse quote cert data: %v", err)
	}

	var tdquote = TDXQuote{}
	var quoteLen = len(quote)
	tdquote.Quote = make([]byte, quoteLen)
	tdquote.Quote = quote
	tdquote.Version = header.Version
	copy(tdquote.Tdreport[:], quote[QuoteTDReportOffset:QuoteAuthDataSizeOffset])
	tdquote.TeeType = header.TeeType
	tdquote.TeeTcbSvn = tdreport.TeeTcbSvn
	tdquote.Mrseam = tdreport.Mrseam
	tdquote.Mrsignerseam = tdreport.Mrsignerseam
	tdquote.SeamAttributes = tdreport.SeamAttributes
	tdquote.TdAttributes = tdreport.TdAttributes
	tdquote.Xfam = tdreport.Xfam
	tdquote.Mrtd = tdreport.Mrtd
	tdquote.Mrconfigid = tdreport.Mrconfigid
	tdquote.Mrowner = tdreport.Mrowner
	tdquote.Mrownerconfig = tdreport.Mrownerconfig
	tdquote.Rtmrs = tdreport.Rtmrs
	tdquote.ReportData = tdreport.ReportData
	tdquote.Signature = signature
	tdquote.AttestationKey = attestationKey
	tdquote.CertData = make([]byte, authSize)
	tdquote.CertData = certData

	return tdquote, nil
}

func parseTPMQuote(quote []byte) (interface{}, error) {
	// TODO: add vTPM support later
	return nil, pkgerrors.New("TPM support to be implemented later.")
}
