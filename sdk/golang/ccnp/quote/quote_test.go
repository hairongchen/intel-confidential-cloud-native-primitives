/*
* Copyright (c) 2023, Intel Corporation. All rights reserved.<BR>
* SPDX-License-Identifier: Apache-2.0
 */

package quote

import (
	"encoding/base64"
	"testing"
)

const (
	VALID_QUOTE_ENCODED          = "BAACAIEAAAAAAAAAk5pyM/ecTKmUCg2zlX8GB/TNy6L5WRm2i7HjVZnPfTkAAAAABAAGAAAAAAAAAAAAAAAAAEj6aZSdsIAC7oQlKEf1cpiLHW5WjsE1P2TLbA/ZBTdfaa2VnA6vd0escKOSeJMCoQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAUAAAAIDnAgYAAAAAABfVphf2NgeaCjRYyuyU3/+bak+Es43vtr/WLebzXXqIeCPHAGeQloLQcHt8WhbzigAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACtXqZL6zfdtY4RHFnIhccwI8cNiRPCJYxCSIl/pJH7CnbOWGFMXGit1hwDQOnL6QamKCwEsSXOxbhdT3dbcZjkSfbq2r78jZFZt/iut8NB6bd/Gv3MyY8ivM6m68GMOVtcGEiNuFEbi2re+bkwumDYuJJXNImezouBdEdilIrnbqAfsRxX9KWcHQ76LFwLsrAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEqZLq1fn8dpca229PuQuc3vVPhqL9455GUSwpnO0Vh1bt0/mZYNYCXljT6Q/3VkzUF05NMLau3vj/iHcTL/nADMEAAATcG1YWHGlncNbuikKXiJH7hHJdqIZMt6m7hCFFjURi8d8GDYirL9+twexgGmDdKrpGrpve9lmqJ+oUQ/jzIeHLxIZGhJ+x5g28ho+8iJxGI2Pfu9hKipK4OoB9WuZngPhIvHNtBMN+FUJKNyqFYKb14SUrmM5hJJ6N88jw2YBxgGAEYQAAAGBhMVA/8ABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVAAAAAAAAAOcAAAAAAAAAOWseNYAkJ5SHxHr5xWG93BUlhjmq0t2vdgCQ70Y/C4QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANyeKnxvlI8XR040p/xD7QMPfBVj8bq932NAyC4OVKjFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKc+m05BylEOzzSg9gXWhhconfbOHGxvs1T7LK9tmJGPAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAZpnkiNdMi44ItOWdTrDCXx6WcDDqkNyW0LQJGAXOm6IAW77owS9X9TG6fW2oskmg4hrsHbk7Cl/TcGClh99QmIAAAAQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGRobHB0eHwUAXg4AAC0tLS0tQkVHSU4gQ0VSVElGSUNBVEUtLS0tLQpNSUlFOFRDQ0JKZWdBd0lCQWdJVkFPYkpnWGxIRWdzVzVISVpnRHJxZ3NyWWpldHBNQW9HQ0NxR1NNNDlCQU1DCk1IQXhJakFnQmdOVkJBTU1HVWx1ZEdWc0lGTkhXQ0JRUTBzZ1VHeGhkR1p2Y20wZ1EwRXhHakFZQmdOVkJBb00KRVVsdWRHVnNJRU52Y25CdmNtRjBhVzl1TVJRd0VnWURWUVFIREF0VFlXNTBZU0JEYkdGeVlURUxNQWtHQTFVRQpDQXdDUTBFeEN6QUpCZ05WQkFZVEFsVlRNQjRYRFRJek1Ea3hNekEwTkRZek9Wb1hEVE13TURreE16QTBORFl6Ck9Wb3djREVpTUNBR0ExVUVBd3daU1c1MFpXd2dVMGRZSUZCRFN5QkRaWEowYVdacFkyRjBaVEVhTUJnR0ExVUUKQ2d3UlNXNTBaV3dnUTI5eWNHOXlZWFJwYjI0eEZEQVNCZ05WQkFjTUMxTmhiblJoSUVOc1lYSmhNUXN3Q1FZRApWUVFJREFKRFFURUxNQWtHQTFVRUJoTUNWVk13V1RBVEJnY3Foa2pPUFFJQkJnZ3Foa2pPUFFNQkJ3TkNBQVRVCjhVampMdU44TWt0aExoQVRta2M2UThOalB3aFJtWXU2MklTNk9zQ3FxbU5YbEplOVh5TFhyb2VmQW1VNzJxaHYKMjFDMzVRTFNUeGdsWEJQOXpKQXdvNElERERDQ0F3Z3dId1lEVlIwakJCZ3dGb0FVbFc5ZHpiMGI0ZWxBU2NuVQo5RFBPQVZjTDNsUXdhd1lEVlIwZkJHUXdZakJnb0Y2Z1hJWmFhSFIwY0hNNkx5OWhjR2t1ZEhKMWMzUmxaSE5sCmNuWnBZMlZ6TG1sdWRHVnNMbU52YlM5elozZ3ZZMlZ5ZEdsbWFXTmhkR2x2Ymk5Mk5DOXdZMnRqY213L1kyRTkKY0d4aGRHWnZjbTBtWlc1amIyUnBibWM5WkdWeU1CMEdBMVVkRGdRV0JCUTdiVWx2SURyL1puRjBoK2dSUGZDQwpMTGRLMnpBT0JnTlZIUThCQWY4RUJBTUNCc0F3REFZRFZSMFRBUUgvQkFJd0FEQ0NBamtHQ1NxR1NJYjRUUUVOCkFRU0NBaW93Z2dJbU1CNEdDaXFHU0liNFRRRU5BUUVFRU5YSC96dy93OE5ydWNFOHl1M3EraTB3Z2dGakJnb3EKaGtpRytFMEJEUUVDTUlJQlV6QVFCZ3NxaGtpRytFMEJEUUVDQVFJQkJqQVFCZ3NxaGtpRytFMEJEUUVDQWdJQgpCakFRQmdzcWhraUcrRTBCRFFFQ0F3SUJBakFRQmdzcWhraUcrRTBCRFFFQ0JBSUJBakFRQmdzcWhraUcrRTBCCkRRRUNCUUlCQXpBUUJnc3Foa2lHK0UwQkRRRUNCZ0lCQVRBUUJnc3Foa2lHK0UwQkRRRUNCd0lCQURBUUJnc3EKaGtpRytFMEJEUUVDQ0FJQkF6QVFCZ3NxaGtpRytFMEJEUUVDQ1FJQkFEQVFCZ3NxaGtpRytFMEJEUUVDQ2dJQgpBREFRQmdzcWhraUcrRTBCRFFFQ0N3SUJBREFRQmdzcWhraUcrRTBCRFFFQ0RBSUJBREFRQmdzcWhraUcrRTBCCkRRRUNEUUlCQURBUUJnc3Foa2lHK0UwQkRRRUNEZ0lCQURBUUJnc3Foa2lHK0UwQkRRRUNEd0lCQURBUUJnc3EKaGtpRytFMEJEUUVDRUFJQkFEQVFCZ3NxaGtpRytFMEJEUUVDRVFJQkN6QWZCZ3NxaGtpRytFMEJEUUVDRWdRUQpCZ1lDQWdNQkFBTUFBQUFBQUFBQUFEQVFCZ29xaGtpRytFMEJEUUVEQkFJQUFEQVVCZ29xaGtpRytFMEJEUUVFCkJBWUFnRzhGQUFBd0R3WUtLb1pJaHZoTkFRMEJCUW9CQVRBZUJnb3Foa2lHK0UwQkRRRUdCQkM4MEhmWGk4QXEKa1AzeHQyVWxjMVFPTUVRR0NpcUdTSWI0VFFFTkFRY3dOakFRQmdzcWhraUcrRTBCRFFFSEFRRUIvekFRQmdzcQpoa2lHK0UwQkRRRUhBZ0VCQURBUUJnc3Foa2lHK0UwQkRRRUhBd0VCL3pBS0JnZ3Foa2pPUFFRREFnTklBREJGCkFpRUFyMFJGNi9RZDE3T3pCOTZlYWJHSWJoQmN1b2QxcTZabkt1YksxUVV6d1FVQ0lFTnFoUkJabk92LzJhcXQKSWdQTE1NenovSkU0U25FaUVjVXh4M05TN09XSwotLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tCi0tLS0tQkVHSU4gQ0VSVElGSUNBVEUtLS0tLQpNSUlDbGpDQ0FqMmdBd0lCQWdJVkFKVnZYYzI5RytIcFFFbkoxUFF6emdGWEM5NVVNQW9HQ0NxR1NNNDlCQU1DCk1HZ3hHakFZQmdOVkJBTU1FVWx1ZEdWc0lGTkhXQ0JTYjI5MElFTkJNUm93R0FZRFZRUUtEQkZKYm5SbGJDQkQKYjNKd2IzSmhkR2x2YmpFVU1CSUdBMVVFQnd3TFUyRnVkR0VnUTJ4aGNtRXhDekFKQmdOVkJBZ01Ba05CTVFzdwpDUVlEVlFRR0V3SlZVekFlRncweE9EQTFNakV4TURVd01UQmFGdzB6TXpBMU1qRXhNRFV3TVRCYU1IQXhJakFnCkJnTlZCQU1NR1VsdWRHVnNJRk5IV0NCUVEwc2dVR3hoZEdadmNtMGdRMEV4R2pBWUJnTlZCQW9NRVVsdWRHVnMKSUVOdmNuQnZjbUYwYVc5dU1SUXdFZ1lEVlFRSERBdFRZVzUwWVNCRGJHRnlZVEVMTUFrR0ExVUVDQXdDUTBFeApDekFKQmdOVkJBWVRBbFZUTUZrd0V3WUhLb1pJemowQ0FRWUlLb1pJemowREFRY0RRZ0FFTlNCLzd0MjFsWFNPCjJDdXpweHc3NGVKQjcyRXlER2dXNXJYQ3R4MnRWVExxNmhLazZ6K1VpUlpDbnFSN3BzT3ZncUZlU3hsbVRsSmwKZVRtaTJXWXozcU9CdXpDQnVEQWZCZ05WSFNNRUdEQVdnQlFpWlF6V1dwMDBpZk9EdEpWU3YxQWJPU2NHckRCUwpCZ05WSFI4RVN6QkpNRWVnUmFCRGhrRm9kSFJ3Y3pvdkwyTmxjblJwWm1sallYUmxjeTUwY25WemRHVmtjMlZ5CmRtbGpaWE11YVc1MFpXd3VZMjl0TDBsdWRHVnNVMGRZVW05dmRFTkJMbVJsY2pBZEJnTlZIUTRFRmdRVWxXOWQKemIwYjRlbEFTY25VOURQT0FWY0wzbFF3RGdZRFZSMFBBUUgvQkFRREFnRUdNQklHQTFVZEV3RUIvd1FJTUFZQgpBZjhDQVFBd0NnWUlLb1pJemowRUF3SURSd0F3UkFJZ1hzVmtpMHcraTZWWUdXM1VGLzIydWFYZTBZSkRqMVVlCm5BK1RqRDFhaTVjQ0lDWWIxU0FtRDV4a2ZUVnB2bzRVb3lpU1l4ckRXTG1VUjRDSTlOS3lmUE4rCi0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0KLS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUNqekNDQWpTZ0F3SUJBZ0lVSW1VTTFscWROSW56ZzdTVlVyOVFHemtuQnF3d0NnWUlLb1pJemowRUF3SXcKYURFYU1CZ0dBMVVFQXd3UlNXNTBaV3dnVTBkWUlGSnZiM1FnUTBFeEdqQVlCZ05WQkFvTUVVbHVkR1ZzSUVOdgpjbkJ2Y21GMGFXOXVNUlF3RWdZRFZRUUhEQXRUWVc1MFlTQkRiR0Z5WVRFTE1Ba0dBMVVFQ0F3Q1EwRXhDekFKCkJnTlZCQVlUQWxWVE1CNFhEVEU0TURVeU1URXdORFV4TUZvWERUUTVNVEl6TVRJek5UazFPVm93YURFYU1CZ0cKQTFVRUF3d1JTVzUwWld3Z1UwZFlJRkp2YjNRZ1EwRXhHakFZQmdOVkJBb01FVWx1ZEdWc0lFTnZjbkJ2Y21GMAphVzl1TVJRd0VnWURWUVFIREF0VFlXNTBZU0JEYkdGeVlURUxNQWtHQTFVRUNBd0NRMEV4Q3pBSkJnTlZCQVlUCkFsVlRNRmt3RXdZSEtvWkl6ajBDQVFZSUtvWkl6ajBEQVFjRFFnQUVDNm5Fd01ESVlaT2ovaVBXc0N6YUVLaTcKMU9pT1NMUkZoV0dqYm5CVkpmVm5rWTR1M0lqa0RZWUwwTXhPNG1xc3lZamxCYWxUVll4RlAyc0pCSzV6bEtPQgp1ekNCdURBZkJnTlZIU01FR0RBV2dCUWlaUXpXV3AwMGlmT0R0SlZTdjFBYk9TY0dyREJTQmdOVkhSOEVTekJKCk1FZWdSYUJEaGtGb2RIUndjem92TDJObGNuUnBabWxqWVhSbGN5NTBjblZ6ZEdWa2MyVnlkbWxqWlhNdWFXNTAKWld3dVkyOXRMMGx1ZEdWc1UwZFlVbTl2ZEVOQkxtUmxjakFkQmdOVkhRNEVGZ1FVSW1VTTFscWROSW56ZzdTVgpVcjlRR3prbkJxd3dEZ1lEVlIwUEFRSC9CQVFEQWdFR01CSUdBMVVkRXdFQi93UUlNQVlCQWY4Q0FRRXdDZ1lJCktvWkl6ajBFQXdJRFNRQXdSZ0loQU9XLzVRa1IrUzlDaVNEY05vb3dMdVBSTHNXR2YvWWk3R1NYOTRCZ3dUd2cKQWlFQTRKMGxySG9NcytYbzVvL3NYNk85UVd4SFJBdlpVR09kUlE3Y3ZxUlhhcUk9Ci0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0KAA=="
	EXPECTED_REPORT_DATA_ENCODED = "+lhdichR3TOKcNz1Naoqkv7ng23Wr/EiZYPojgmWKT8WvACcZSgm4PxccGaVoDzdzjcvE57/TROVnabx9dPqAA=="
	USER_DATA_ENCODED            = "YWJjZGVmZw=="
	NONCE_ENCODED                = "MTIzNDU2Nzg="
	TDX_QUOTE_VERSION            = 4
	TEE_TYPE_TDX                 = 129
	TDX_TCB_SVN_LENGTH           = 16
	TDX_MRSEAM_LENGTH            = 48
	TDX_MRSINGERSEAM_LENGTH      = 48
	TDX_SEAM_ATTRIBUTES_LENGTH   = 8
	TDX_TD_ATTRIBUTES_LENGTH     = 8
	TDX_XFAM_LENGTH              = 8
	TDX_MRTD_LENGTH              = 48
	TDX_MRCONFIGID_LENGTH        = 48
	TDX_MROWNER_LENGTH           = 48
	TDX_MROWNERCONFIG_LENGTH     = 48
	TDX_RTMR_LENGTH              = 192
	TDX_REPORT_DATA_LENGTH       = 64
	TDX_SIGNATURE_LENGTH         = 64
	TDX_ATTESTATION_KEY_LENGTH   = 64
)

func TestparseTDXQuote(t *testing.T) {
	quoteRaw, errDecode := base64.StdEncoding.DecodeString(VALID_QUOTE_ENCODED)
	if errDecode != nil {
		t.Fatalf("[parseTDXQuote] decode quote error: %v", errDecode)
	}

	var ret interface{}
	ret, errParse := parseTDXQuote(quoteRaw)
	if errParse != nil {
		t.Fatalf("[parseTDXQuote] parse quote error: %v", errParse)
	}

	switch ret.(type) {
	case TDXQuote:
		var q, _ = ret.(TDXQuote)
		report_slice := make([]byte, len(q.Report_data))
		copy(report_slice[:], q.Report_data[:])
		report_data_encoded := base64.StdEncoding.EncodeToString(report_slice)
		if report_data_encoded != EXPECTED_REPORT_DATA_ENCODED {
			t.Fatalf(`parseTDXQuote, report_data retrieve = %v, want %v`,
				report_data_encoded, EXPECTED_REPORT_DATA_ENCODED)
		}
	default:
		t.Fatalf(`parseTDXQuote, unexpected quote type`)
	}
}

func TestGetQuote(t *testing.T) {
	var ret interface{}
	ret, err := GetQuote(USER_DATA_ENCODED, NONCE_ENCODED)
	if err != nil {
		t.Fatalf("[parseTDXQuote] get quote error: %v", err)
	}
	switch ret.(type) {
	case TDXQuote:
		var q, _ = ret.(TDXQuote)
		if len(q.Quote) == 0 {
			t.Fatalf("[GetQuote] quote length is 0")
		}

		if q.Version != TDX_QUOTE_VERSION {
			t.Fatalf("[GetQuote] quote version retrieve: %v, expected: %v", q.Version, TDX_QUOTE_VERSION)
		}

		if len(q.Tdreport) == 0 {
			t.Fatalf("[GetQuote] TDReport length is 0")
		}

		if q.Tee_type != TEE_TYPE_TDX {
			t.Fatalf("[GetQuote] Tee_type retrieve: %v, expected: %v", q.Tee_type, TEE_TYPE_TDX)
		}

		if len(q.Tee_tcb_svn) != TDX_TCB_SVN_LENGTH {
			t.Fatalf("[GetQuote] Tee_type retrieve: %v, expected: %v", len(q.Tee_tcb_svn), TDX_TCB_SVN_LENGTH)
		}

		if len(q.Mrseam) != TDX_MRSEAM_LENGTH {
			t.Fatalf("[GetQuote] Mrseam retrieve: %v, expected: %v", len(q.Mrseam), TDX_MRSEAM_LENGTH)
		}

		if len(q.Mrsignerseam) != TDX_MRSINGERSEAM_LENGTH {
			t.Fatalf("[GetQuote] Mrsignerseam retrieve: %v, expected: %v", len(q.Mrsignerseam), TDX_MRSINGERSEAM_LENGTH)
		}

		if len(q.Seam_attributes) != TDX_SEAM_ATTRIBUTES_LENGTH {
			t.Fatalf("[GetQuote] Seam_attributes length retrieve: %v, expected: %v", len(q.Seam_attributes), TDX_SEAM_ATTRIBUTES_LENGTH)
		}

		if len(q.Td_attributes) != TDX_TD_ATTRIBUTES_LENGTH {
			t.Fatalf("[GetQuote] Td_attributes length retrieve: %v, expected: %v", len(q.Td_attributes), TDX_TD_ATTRIBUTES_LENGTH)
		}

		if len(q.Xfam) != TDX_XFAM_LENGTH {
			t.Fatalf("[GetQuote] Xfam length retrieve: %v, expected: %v", len(q.Xfam), TDX_XFAM_LENGTH)
		}

		if len(q.Mrtd) != TDX_MRTD_LENGTH {
			t.Fatalf("[GetQuote] Mrtd length retrieve: %v, expected: %v", len(q.Mrtd), TDX_MRTD_LENGTH)
		}

		if len(q.Mrconfigid) != TDX_MRCONFIGID_LENGTH {
			t.Fatalf("[GetQuote] Mrconfigid length retrieve: %v, expected: %v", len(q.Mrconfigid), TDX_MRCONFIGID_LENGTH)
		}

		if len(q.Mrowner) != TDX_MROWNER_LENGTH {
			t.Fatalf("[GetQuote] Mrowner length retrieve: %v, expected: %v", len(q.Mrowner), TDX_MROWNER_LENGTH)
		}

		if len(q.Mrownerconfig) != TDX_MROWNERCONFIG_LENGTH {
			t.Fatalf("[GetQuote] Mrownerconfig length retrieve: %v, expected: %v", len(q.Mrownerconfig), TDX_MROWNERCONFIG_LENGTH)
		}

		if len(q.Rtmrs) != TDX_RTMR_LENGTH {
			t.Fatalf("[GetQuote] Rtmrs length retrieve: %v, expected: %v", len(q.Rtmrs), TDX_RTMR_LENGTH)
		}

		if len(q.Report_data) != TDX_REPORT_DATA_LENGTH {
			t.Fatalf("[GetQuote] Report_data length retrieve: %v, expected: %v", len(q.Report_data), TDX_REPORT_DATA_LENGTH)
		}

		report_slice := make([]byte, len(q.Report_data))
		copy(report_slice[:], q.Report_data[:])
		report_data_encoded := base64.StdEncoding.EncodeToString(report_slice)
		if report_data_encoded != EXPECTED_REPORT_DATA_ENCODED {
			t.Fatalf(`parseTDXQuote, report_data retrieve = %v, want %v`,
				report_data_encoded, EXPECTED_REPORT_DATA_ENCODED)
		}

		if len(q.Signature) != TDX_SIGNATURE_LENGTH {
			t.Fatalf("[GetQuote] Signature length retrieve: %v, expected: %v", len(q.Signature), TDX_SIGNATURE_LENGTH)
		}

		if len(q.Attestation_key) != TDX_ATTESTATION_KEY_LENGTH {
			t.Fatalf("[GetQuote] Attestation_key length retrieve: %v, expected: %v", len(q.Attestation_key), TDX_ATTESTATION_KEY_LENGTH)
		}

		if len(q.Cert_data) == 0 {
			t.Fatalf("[GetQuote] Cert_data length is 0")
		}

	default:
		t.Fatalf(`parseTDXQuote, unexpected quote type`)
	}
}
