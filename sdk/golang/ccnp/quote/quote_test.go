/*
* Copyright (c) 2023, Intel Corporation. All rights reserved.<BR>
* SPDX-License-Identifier: Apache-2.0
 */

package quote

import (
	"encoding/base64"
	"testing"
)

const (
	VALID_QUOTE_ENCODED          = "BAACAIEAAAAAAAAAk5pyM/ecTKmUCg2zlX8GB9VoWcc1+7SRKSdVsujoI7YAAAAABAAGAAAAAAAAAAAAAAAAAEj6aZSdsIAC7oQlKEf1cpiLHW5WjsE1P2TLbA/ZBTdfaa2VnA6vd0escKOSeJMCoQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAUAAAAIDnAgYAAAAAABfVphf2NgeaCjRYyuyU3/+bak+Es43vtr/WLebzXXqIeCPHAGeQloLQcHt8WhbzigAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACtXqZL6zfdtY4RHFnIhccwI8cNiRPCJYxCSIl/pJH7CnbOWGFMXGit1hwDQOnL6QamKCwEsSXOxbhdT3dbcZjkSfbq2r78jZFZt/iut8NB6bd/Gv3MyY8ivM6m68GMOVtcGEiNuFEbi2re+bkwumDYuJJXNImezouBdEdilIrnbqAfsRxX9KWcHQ76LFwLsrAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAF1HHFNzvaaCV4l+d4zRo9cNr+FlQMPEyg8lpvGNMYCdpIRDMgkgolnzv7GDBJ+caAvBEtlc18Jikb/TVbt2J1DMEAAAcP7yQBCnxpfkNObEg3cu+ZPNwlOqKtuprbxkkzvHKm7MEY3lwO4D3wpvPfuy61fLXN1g6qKL/Zalp1ku4Tpk9pqWlSV8WNbCZdEzQg6SJQuR71HTg9lnq7D/8/YM3Dicka45sYZmgTf1rHl+Ta8th1ID3dcz92Tl6DnJB47VPU0GAEYQAAAGBhMVA/8ABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVAAAAAAAAAOcAAAAAAAAAOWseNYAkJ5SHxHr5xWG93BUlhjmq0t2vdgCQ70Y/C4QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANyeKnxvlI8XR040p/xD7QMPfBVj8bq932NAyC4OVKjFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGPxraaayUhlgmee99nba2LwhwoofhQW1chDzLhCYPoVAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADYMYOwjPVV15CoDdE36zBAkRjx27eeywUXxdL+CPOiBJ59J3tnoHEz/Se166mPgT2M4Ho7/wqHsqXW8GsyAbAFIAAAAQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGRobHB0eHwUAXg4AAC0tLS0tQkVHSU4gQ0VSVElGSUNBVEUtLS0tLQpNSUlFOFRDQ0JKZWdBd0lCQWdJVkFNVUVFZWxSY2ZmQURvcFowT2N2RXpmbGNsaGRNQW9HQ0NxR1NNNDlCQU1DCk1IQXhJakFnQmdOVkJBTU1HVWx1ZEdWc0lGTkhXQ0JRUTBzZ1VHeGhkR1p2Y20wZ1EwRXhHakFZQmdOVkJBb00KRVVsdWRHVnNJRU52Y25CdmNtRjBhVzl1TVJRd0VnWURWUVFIREF0VFlXNTBZU0JEYkdGeVlURUxNQWtHQTFVRQpDQXdDUTBFeEN6QUpCZ05WQkFZVEFsVlRNQjRYRFRJek1URXdNekF5TVRNMU1Gb1hEVE13TVRFd016QXlNVE0xCk1Gb3djREVpTUNBR0ExVUVBd3daU1c1MFpXd2dVMGRZSUZCRFN5QkRaWEowYVdacFkyRjBaVEVhTUJnR0ExVUUKQ2d3UlNXNTBaV3dnUTI5eWNHOXlZWFJwYjI0eEZEQVNCZ05WQkFjTUMxTmhiblJoSUVOc1lYSmhNUXN3Q1FZRApWUVFJREFKRFFURUxNQWtHQTFVRUJoTUNWVk13V1RBVEJnY3Foa2pPUFFJQkJnZ3Foa2pPUFFNQkJ3TkNBQVIxCmg4VkJ6b3dyT043V2ZYeXNLMnhuMTJicHhKYUdiRHpMY1p2WjExM24yRUxRUGhvYWRlTExtOGxaK21LdXhDTmEKSWx1eWZkUGxkanV6eHFlTE82dnpvNElERERDQ0F3Z3dId1lEVlIwakJCZ3dGb0FVbFc5ZHpiMGI0ZWxBU2NuVQo5RFBPQVZjTDNsUXdhd1lEVlIwZkJHUXdZakJnb0Y2Z1hJWmFhSFIwY0hNNkx5OWhjR2t1ZEhKMWMzUmxaSE5sCmNuWnBZMlZ6TG1sdWRHVnNMbU52YlM5elozZ3ZZMlZ5ZEdsbWFXTmhkR2x2Ymk5Mk5DOXdZMnRqY213L1kyRTkKY0d4aGRHWnZjbTBtWlc1amIyUnBibWM5WkdWeU1CMEdBMVVkRGdRV0JCUm9jZlpWbFVBYU94cG5XR0tkOEh4bApweFQwTVRBT0JnTlZIUThCQWY4RUJBTUNCc0F3REFZRFZSMFRBUUgvQkFJd0FEQ0NBamtHQ1NxR1NJYjRUUUVOCkFRU0NBaW93Z2dJbU1CNEdDaXFHU0liNFRRRU5BUUVFRUU4SGJRZ1drdUp4Njh3RXRVVU11RFF3Z2dGakJnb3EKaGtpRytFMEJEUUVDTUlJQlV6QVFCZ3NxaGtpRytFMEJEUUVDQVFJQkJqQVFCZ3NxaGtpRytFMEJEUUVDQWdJQgpCakFRQmdzcWhraUcrRTBCRFFFQ0F3SUJBakFRQmdzcWhraUcrRTBCRFFFQ0JBSUJBakFRQmdzcWhraUcrRTBCCkRRRUNCUUlCQXpBUUJnc3Foa2lHK0UwQkRRRUNCZ0lCQVRBUUJnc3Foa2lHK0UwQkRRRUNCd0lCQURBUUJnc3EKaGtpRytFMEJEUUVDQ0FJQkF6QVFCZ3NxaGtpRytFMEJEUUVDQ1FJQkFEQVFCZ3NxaGtpRytFMEJEUUVDQ2dJQgpBREFRQmdzcWhraUcrRTBCRFFFQ0N3SUJBREFRQmdzcWhraUcrRTBCRFFFQ0RBSUJBREFRQmdzcWhraUcrRTBCCkRRRUNEUUlCQURBUUJnc3Foa2lHK0UwQkRRRUNEZ0lCQURBUUJnc3Foa2lHK0UwQkRRRUNEd0lCQURBUUJnc3EKaGtpRytFMEJEUUVDRUFJQkFEQVFCZ3NxaGtpRytFMEJEUUVDRVFJQkN6QWZCZ3NxaGtpRytFMEJEUUVDRWdRUQpCZ1lDQWdNQkFBTUFBQUFBQUFBQUFEQVFCZ29xaGtpRytFMEJEUUVEQkFJQUFEQVVCZ29xaGtpRytFMEJEUUVFCkJBWUFnRzhGQUFBd0R3WUtLb1pJaHZoTkFRMEJCUW9CQVRBZUJnb3Foa2lHK0UwQkRRRUdCQkJKMnlLQ3ZIY1kKcG03RDBzeld0M0o4TUVRR0NpcUdTSWI0VFFFTkFRY3dOakFRQmdzcWhraUcrRTBCRFFFSEFRRUIvekFRQmdzcQpoa2lHK0UwQkRRRUhBZ0VCQURBUUJnc3Foa2lHK0UwQkRRRUhBd0VCL3pBS0JnZ3Foa2pPUFFRREFnTklBREJGCkFpRUFzODNLOWlmZWhRS09FSWJMNnZWdTBoUTVreUlwejViNkVEWGlHOC8yckZRQ0lFU2NoT2U0N0pQaHNsY00KeFdLTys3NGlaOEZ5aTlJZUJIT25EckptdlVYegotLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tCi0tLS0tQkVHSU4gQ0VSVElGSUNBVEUtLS0tLQpNSUlDbGpDQ0FqMmdBd0lCQWdJVkFKVnZYYzI5RytIcFFFbkoxUFF6emdGWEM5NVVNQW9HQ0NxR1NNNDlCQU1DCk1HZ3hHakFZQmdOVkJBTU1FVWx1ZEdWc0lGTkhXQ0JTYjI5MElFTkJNUm93R0FZRFZRUUtEQkZKYm5SbGJDQkQKYjNKd2IzSmhkR2x2YmpFVU1CSUdBMVVFQnd3TFUyRnVkR0VnUTJ4aGNtRXhDekFKQmdOVkJBZ01Ba05CTVFzdwpDUVlEVlFRR0V3SlZVekFlRncweE9EQTFNakV4TURVd01UQmFGdzB6TXpBMU1qRXhNRFV3TVRCYU1IQXhJakFnCkJnTlZCQU1NR1VsdWRHVnNJRk5IV0NCUVEwc2dVR3hoZEdadmNtMGdRMEV4R2pBWUJnTlZCQW9NRVVsdWRHVnMKSUVOdmNuQnZjbUYwYVc5dU1SUXdFZ1lEVlFRSERBdFRZVzUwWVNCRGJHRnlZVEVMTUFrR0ExVUVDQXdDUTBFeApDekFKQmdOVkJBWVRBbFZUTUZrd0V3WUhLb1pJemowQ0FRWUlLb1pJemowREFRY0RRZ0FFTlNCLzd0MjFsWFNPCjJDdXpweHc3NGVKQjcyRXlER2dXNXJYQ3R4MnRWVExxNmhLazZ6K1VpUlpDbnFSN3BzT3ZncUZlU3hsbVRsSmwKZVRtaTJXWXozcU9CdXpDQnVEQWZCZ05WSFNNRUdEQVdnQlFpWlF6V1dwMDBpZk9EdEpWU3YxQWJPU2NHckRCUwpCZ05WSFI4RVN6QkpNRWVnUmFCRGhrRm9kSFJ3Y3pvdkwyTmxjblJwWm1sallYUmxjeTUwY25WemRHVmtjMlZ5CmRtbGpaWE11YVc1MFpXd3VZMjl0TDBsdWRHVnNVMGRZVW05dmRFTkJMbVJsY2pBZEJnTlZIUTRFRmdRVWxXOWQKemIwYjRlbEFTY25VOURQT0FWY0wzbFF3RGdZRFZSMFBBUUgvQkFRREFnRUdNQklHQTFVZEV3RUIvd1FJTUFZQgpBZjhDQVFBd0NnWUlLb1pJemowRUF3SURSd0F3UkFJZ1hzVmtpMHcraTZWWUdXM1VGLzIydWFYZTBZSkRqMVVlCm5BK1RqRDFhaTVjQ0lDWWIxU0FtRDV4a2ZUVnB2bzRVb3lpU1l4ckRXTG1VUjRDSTlOS3lmUE4rCi0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0KLS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUNqekNDQWpTZ0F3SUJBZ0lVSW1VTTFscWROSW56ZzdTVlVyOVFHemtuQnF3d0NnWUlLb1pJemowRUF3SXcKYURFYU1CZ0dBMVVFQXd3UlNXNTBaV3dnVTBkWUlGSnZiM1FnUTBFeEdqQVlCZ05WQkFvTUVVbHVkR1ZzSUVOdgpjbkJ2Y21GMGFXOXVNUlF3RWdZRFZRUUhEQXRUWVc1MFlTQkRiR0Z5WVRFTE1Ba0dBMVVFQ0F3Q1EwRXhDekFKCkJnTlZCQVlUQWxWVE1CNFhEVEU0TURVeU1URXdORFV4TUZvWERUUTVNVEl6TVRJek5UazFPVm93YURFYU1CZ0cKQTFVRUF3d1JTVzUwWld3Z1UwZFlJRkp2YjNRZ1EwRXhHakFZQmdOVkJBb01FVWx1ZEdWc0lFTnZjbkJ2Y21GMAphVzl1TVJRd0VnWURWUVFIREF0VFlXNTBZU0JEYkdGeVlURUxNQWtHQTFVRUNBd0NRMEV4Q3pBSkJnTlZCQVlUCkFsVlRNRmt3RXdZSEtvWkl6ajBDQVFZSUtvWkl6ajBEQVFjRFFnQUVDNm5Fd01ESVlaT2ovaVBXc0N6YUVLaTcKMU9pT1NMUkZoV0dqYm5CVkpmVm5rWTR1M0lqa0RZWUwwTXhPNG1xc3lZamxCYWxUVll4RlAyc0pCSzV6bEtPQgp1ekNCdURBZkJnTlZIU01FR0RBV2dCUWlaUXpXV3AwMGlmT0R0SlZTdjFBYk9TY0dyREJTQmdOVkhSOEVTekJKCk1FZWdSYUJEaGtGb2RIUndjem92TDJObGNuUnBabWxqWVhSbGN5NTBjblZ6ZEdWa2MyVnlkbWxqWlhNdWFXNTAKWld3dVkyOXRMMGx1ZEdWc1UwZFlVbTl2ZEVOQkxtUmxjakFkQmdOVkhRNEVGZ1FVSW1VTTFscWROSW56ZzdTVgpVcjlRR3prbkJxd3dEZ1lEVlIwUEFRSC9CQVFEQWdFR01CSUdBMVVkRXdFQi93UUlNQVlCQWY4Q0FRRXdDZ1lJCktvWkl6ajBFQXdJRFNRQXdSZ0loQU9XLzVRa1IrUzlDaVNEY05vb3dMdVBSTHNXR2YvWWk3R1NYOTRCZ3dUd2cKQWlFQTRKMGxySG9NcytYbzVvL3NYNk85UVd4SFJBdlpVR09kUlE3Y3ZxUlhhcUk9Ci0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0KAA=="
	EXPECTED_REPORT_DATA_ENCODED = "XUccU3O9poJXiX53jNGj1w2v4WVAw8TKDyWm8Y0xgJ2khEMyCSCiWfO/sYMEn5xoC8ES2VzXwmKRv9NVu3YnUA=="
	USER_DATA_ENCODED            = "YWJjZGVmZw=="
	NONCE_ENCODED                = "MTIzNDU2Nzg="
	TDX_QUOTE_VERSION            = 4
	TEE_TYPE_TDX                 = 129
	TDX_TCB_SVN_LENGTH           = 16
	TDX_MRSEAM_LENGTH            = 48
	TDX_MRSINGERSEAM_LENGTH      = 48
	TDX_SEAM_ATTRIBUTES_LENGTH   = 8
	TDX_TD_ATTRIBUTES_LENGTH     = 8
	TDX_XFAM_LENGTH              = 8
	TDX_MRTD_LENGTH              = 48
	TDX_MRCONFIGID_LENGTH        = 48
	TDX_MROWNER_LENGTH           = 48
	TDX_MROWNERCONFIG_LENGTH     = 48
	TDX_RTMR_LENGTH              = 192
	TDX_REPORT_DATA_LENGTH       = 64
	TDX_SIGNATURE_LENGTH         = 64
	TDX_ATTESTATION_KEY_LENGTH   = 64
)

func TestParseTDXQuote(t *testing.T) {
	quoteRaw, errDecode := base64.StdEncoding.DecodeString(VALID_QUOTE_ENCODED)
	if errDecode != nil {
		t.Fatalf("[parseTDXQuote] decode quote error: %v", errDecode)
	}

	var ret interface{}
	ret, errParse := parseTDXQuote(quoteRaw)
	if errParse != nil {
		t.Fatalf("[parseTDXQuote] parse quote error: %v", errParse)
	}

	switch ret.(type) {
	case TDXQuote:
		var q, _ = ret.(TDXQuote)
		reportSlice := make([]byte, len(q.ReportData))
		copy(reportSlice[:], q.ReportData[:])
		reportDataEncoded := base64.StdEncoding.EncodeToString(reportSlice)
		if reportDataEncoded != EXPECTED_REPORT_DATA_ENCODED {
			t.Fatalf(`parseTDXQuote, Report Data retrieve = %v, want %v`,
				reportDataEncoded, EXPECTED_REPORT_DATA_ENCODED)
		}
	default:
		t.Fatalf(`parseTDXQuote, unexpected quote type`)
	}
}

func TestGetQuote(t *testing.T) {
	var ret interface{}
	ret, err := GetQuote(USER_DATA_ENCODED, NONCE_ENCODED)
	if err != nil {
		t.Fatalf("[parseTDXQuote] get quote error: %v", err)
	}
	switch ret.(type) {
	case TDXQuote:
		var q, _ = ret.(TDXQuote)
		if len(q.Quote) == 0 {
			t.Fatalf("[GetQuote] quote length is 0")
		}

		if q.Version != TDX_QUOTE_VERSION {
			t.Fatalf("[GetQuote] quote version retrieve: %v, expected: %v", q.Version, TDX_QUOTE_VERSION)
		}

		if len(q.Tdreport) == 0 {
			t.Fatalf("[GetQuote] TDReport length is 0")
		}

		if q.TeeType != TEE_TYPE_TDX {
			t.Fatalf("[GetQuote] TeeType retrieve: %v, expected: %v", q.TeeType, TEE_TYPE_TDX)
		}

		if len(q.TeeTcbSvn) != TDX_TCB_SVN_LENGTH {
			t.Fatalf("[GetQuote] TeeType retrieve: %v, expected: %v", len(q.TeeTcbSvn), TDX_TCB_SVN_LENGTH)
		}

		if len(q.Mrseam) != TDX_MRSEAM_LENGTH {
			t.Fatalf("[GetQuote] Mrseam retrieve: %v, expected: %v", len(q.Mrseam), TDX_MRSEAM_LENGTH)
		}

		if len(q.Mrseamsigner) != TDX_MRSINGERSEAM_LENGTH {
			t.Fatalf("[GetQuote] Mrseamsigner retrieve: %v, expected: %v", len(q.Mrseamsigner), TDX_MRSINGERSEAM_LENGTH)
		}

		if len(q.SeamAttributes) != TDX_SEAM_ATTRIBUTES_LENGTH {
			t.Fatalf("[GetQuote] SeamAttributes length retrieve: %v, expected: %v", len(q.SeamAttributes), TDX_SEAM_ATTRIBUTES_LENGTH)
		}

		if len(q.TdAttributes) != TDX_TD_ATTRIBUTES_LENGTH {
			t.Fatalf("[GetQuote] TdAttributes length retrieve: %v, expected: %v", len(q.TdAttributes), TDX_TD_ATTRIBUTES_LENGTH)
		}

		if len(q.Xfam) != TDX_XFAM_LENGTH {
			t.Fatalf("[GetQuote] Xfam length retrieve: %v, expected: %v", len(q.Xfam), TDX_XFAM_LENGTH)
		}

		if len(q.Mrtd) != TDX_MRTD_LENGTH {
			t.Fatalf("[GetQuote] Mrtd length retrieve: %v, expected: %v", len(q.Mrtd), TDX_MRTD_LENGTH)
		}

		if len(q.Mrconfigid) != TDX_MRCONFIGID_LENGTH {
			t.Fatalf("[GetQuote] Mrconfigid length retrieve: %v, expected: %v", len(q.Mrconfigid), TDX_MRCONFIGID_LENGTH)
		}

		if len(q.Mrowner) != TDX_MROWNER_LENGTH {
			t.Fatalf("[GetQuote] Mrowner length retrieve: %v, expected: %v", len(q.Mrowner), TDX_MROWNER_LENGTH)
		}

		if len(q.Mrownerconfig) != TDX_MROWNERCONFIG_LENGTH {
			t.Fatalf("[GetQuote] Mrownerconfig length retrieve: %v, expected: %v", len(q.Mrownerconfig), TDX_MROWNERCONFIG_LENGTH)
		}

		if len(q.Rtmrs) != TDX_RTMR_LENGTH {
			t.Fatalf("[GetQuote] Rtmrs length retrieve: %v, expected: %v", len(q.Rtmrs), TDX_RTMR_LENGTH)
		}

		if len(q.ReportData) != TDX_REPORT_DATA_LENGTH {
			t.Fatalf("[GetQuote] ReportData length retrieve: %v, expected: %v", len(q.ReportData), TDX_REPORT_DATA_LENGTH)
		}

		reportSlice := make([]byte, len(q.ReportData))
		copy(reportSlice[:], q.ReportData[:])
		reportDataEncoded := base64.StdEncoding.EncodeToString(reportSlice)
		if reportDataEncoded != EXPECTED_REPORT_DATA_ENCODED {
			t.Fatalf(`parseTDXQuote, report data retrieve = %v, want %v`,
				reportDataEncoded, EXPECTED_REPORT_DATA_ENCODED)
		}

		if len(q.Signature) != TDX_SIGNATURE_LENGTH {
			t.Fatalf("[GetQuote] Signature length retrieve: %v, expected: %v", len(q.Signature), TDX_SIGNATURE_LENGTH)
		}

		if len(q.AttestationKey) != TDX_ATTESTATION_KEY_LENGTH {
			t.Fatalf("[GetQuote] AttestationKey length retrieve: %v, expected: %v", len(q.AttestationKey), TDX_ATTESTATION_KEY_LENGTH)
		}

		if len(q.CertData) == 0 {
			t.Fatalf("[GetQuote] CertData length is 0")
		}

	default:
		t.Fatalf(`parseTDXQuote, unexpected quote type`)
	}
}
